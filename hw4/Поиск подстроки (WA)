#include "bits/stdc++.h"

using namespace std;

static const int mod1 = 1e9 + 7, mod2 = 1e9 + 9;

int binmul(int a, int b, int mod) {
    int res = 0;
    while (b) {
        if (b & 1) {
            res += a;
            res %= mod;
        }
        a *= 2;
        a %= mod;
        b >>= 1;
    }
    return res;
}

int main() {
    cin.tie(nullptr); cout.tie(nullptr);
    ios_base::sync_with_stdio(false);

    string s, t;
    cin >> s >> t;
    vector<int> hash_s1(s.size() + 1, 0), hash_t1(t.size() + 1, 0);
    vector<int> hash_s2(s.size() + 1, 0), hash_t2(t.size() + 1, 0);

    srand(time(nullptr));
    int x = rand();

    vector<int> deg1(s.size() + 1, 0);
    deg1[1] = 1;
    vector<int> deg2 = deg1;
    for (int i = 2; i <= s.size(); ++i) {
        deg1[i] = binmul(deg1[i - 1], x, mod1);
        deg2[i] = binmul(deg2[i - 1], x, mod2);
    }

    for (int i = 1; i <= t.size(); ++i) {
        hash_t1[i] = (binmul(t[i - 1], deg1[i], mod1) + hash_t1[i - 1]) % mod1;
        hash_t2[i] = (binmul(t[i - 1], deg2[i], mod2) + hash_t2[i - 1]) % mod2;
    }

    for (int i = 1; i <= s.size(); ++i) {
        hash_s1[i] = (binmul(s[i - 1], deg1[i], mod1) + hash_s1[i - 1]) % mod1;
        hash_s2[i] = (binmul(s[i - 1], deg2[i], mod2) + hash_s2[i - 1]) % mod2;
    }

    for (int i = t.size(); i <= s.size(); ++i) {
        if (binmul(hash_t1.back(), deg1[i - t.size() + 1], mod1) == hash_s1[i] - hash_s1[i - t.size()]
            || binmul(hash_t2.back(), deg2[i - t.size() + 1], mod2) == hash_s2[i] - hash_s2[i - t.size()]) {
            cout << (i - t.size()) << " ";
        }
    }

    return 0;
}

// Это я попробовал немного переписать, но лучше не стало
//#include "bits/stdc++.h"
//
//using namespace std;
//
//static const int mod1 = 1e9 + 7, mod2 = 1e9 + 9;
//
//int binmul(int a, int b, int mod) {
//    int res = 0;
//    while (b) {
//        if (b & 1) {
//            res += a;
//            res %= mod;
//        }
//        a *= 2;
//        a %= mod;
//        b >>= 1;
//    }
//    return res;
//}
//
//int main() {
//    cin.tie(nullptr); cout.tie(nullptr);
//    ios_base::sync_with_stdio(false);
//
//    string s, t;
//    cin >> s >> t;
//
//    if (t.size() > s.size()) {
//        return 0;
//    }
//
//    vector<int> hash_s1(s.size() + 1, 0), hash_s2(s.size() + 1, 0);
//    vector<int> hash_t1(t.size() + 1, 0), hash_t2(t.size() + 1, 0);
//
//    srand(time(nullptr));
//    int x = rand();
//
//    vector<int> deg1(s.size() + 1, 0);
//    deg1.back() = 1;
//    auto deg2 = deg1;
//    for (int i = s.size() - 1; i >= 0; --i) {
//        deg1[i] = binmul(deg1[i + 1], x, mod1);
//        deg2[i] = binmul(deg2[i + 1], x, mod2);
//    }
//
//    for (int i = 1; i <= t.size(); ++i) {
//        hash_t1[i] = (binmul(t[i - 1], deg1[i], mod1) + hash_t1[i - 1]) % mod1;
//        hash_t2[i] = (binmul(t[i - 1], deg2[i], mod2) + hash_t2[i - 1]) % mod2;
//    }
//
//    for (int i = 1; i <= s.size(); ++i) {
//        hash_s1[i] = (binmul(s[i - 1], deg1[i], mod1) + hash_s1[i - 1]) % mod1;
//        hash_s2[i] = (binmul(s[i - 1], deg2[i], mod2) + hash_s2[i - 1]) % mod2;
//    }
//
//    for (int i = 1; i <= s.size() - t.size(); ++i) {
//        if (hash_t1.back() == binmul(hash_s1[i + t.size() - 1] - hash_s1[i - 1], deg1[s.size() - i + 1],mod1)
//            || hash_t2.back() == binmul(hash_s2[i + t.size() - 1] - hash_s2[i - 1], deg2[s.size() - i + 1],mod2)) {
//            cout << i - 1 << " ";
//        }
//    }
//
//    return 0;
//}